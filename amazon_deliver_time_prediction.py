# -*- coding: utf-8 -*-
"""Amazon Deliver time Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1j7DL7luOL8y8wsFUYy8gMEfD1Zp1nz-w
"""

# delivery_time_prediction.py

import pandas as pd
import numpy as np
from datetime import datetime
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from geopy.distance import geodesic
import mlflow

# Load data
df = pd.read_csv("/content/amazon_delivery.csv")

# --- Data Preparation ---
df['Agent_Rating'].fillna(df['Agent_Rating'].median(), inplace=True)
df['Weather'].fillna(df['Weather'].mode()[0], inplace=True)

# Combine datetime
df['Order_Time'] = df['Order_Time'].str.strip() # Remove trailing spaces from Order_Time
df['Order_Datetime'] = pd.to_datetime(df['Order_Date'] + ' ' + df['Order_Time'], errors='coerce') # Use errors='coerce'
df['Pickup_Datetime'] = pd.to_datetime(df['Order_Date'] + ' ' + df['Pickup_Time'], errors='coerce') # Use errors='coerce'
df['Order_to_Pickup_Minutes'] = (df['Pickup_Datetime'] - df['Order_Datetime']).dt.total_seconds() / 60

# Drop rows with missing datetime information
df.dropna(subset=['Order_Datetime'], inplace=True)


# --- Feature Engineering ---
# Calculate distance between store and drop

def calculate_distance(row):
    store = (row['Store_Latitude'], row['Store_Longitude'])
    drop = (row['Drop_Latitude'], row['Drop_Longitude'])
    return geodesic(store, drop).km

df['Distance_km'] = df.apply(calculate_distance, axis=1)

# Extract datetime features
df['Order_Hour'] = df['Order_Datetime'].dt.hour
df['Order_Weekday'] = df['Order_Datetime'].dt.weekday
df['Is_Weekend'] = df['Order_Weekday'].isin([5, 6]).astype(int)

# Encode categorical features
cat_cols = ['Weather', 'Traffic', 'Vehicle', 'Area', 'Category']
le_dict = {}
for col in cat_cols:
    le = LabelEncoder()
    df[col] = le.fit_transform(df[col])
    le_dict[col] = le

# --- Model Development ---
features = [
    'Agent_Age', 'Agent_Rating', 'Distance_km', 'Order_to_Pickup_Minutes',
    'Order_Hour', 'Order_Weekday', 'Is_Weekend'
] + cat_cols

X = df[features]
y = df['Delivery_Time']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

models = {
    'LinearRegression': LinearRegression(),
    'RandomForest': RandomForestRegressor(n_estimators=100, random_state=42),
    'GradientBoosting': GradientBoostingRegressor(n_estimators=100, random_state=42)
}

mlflow.set_experiment("Delivery Time Prediction")

for name, model in models.items():
    with mlflow.start_run(run_name=name):
        model.fit(X_train, y_train)
        preds = model.predict(X_test)

        rmse = np.sqrt(mean_squared_error(y_test, preds)) # Calculate RMSE manually
        mae = mean_absolute_error(y_test, preds)
        r2 = r2_score(y_test, preds)

        mlflow.log_param("model", name)
        mlflow.log_metrics({"RMSE": rmse, "MAE": mae, "R2": r2})

        mlflow.sklearn.log_model(model, name)

        print(f"{name} => RMSE: {rmse:.2f}, MAE: {mae:.2f}, R2: {r2:.2f}")

display(df.isnull().sum())

# eda_visualizations.py

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load cleaned dataset
df = pd.read_csv("/content/amazon_delivery.csv")

# Combine datetime
df['Order_Time'] = df['Order_Time'].str.strip() # Remove trailing spaces from Order_Time
df['Order_Datetime'] = pd.to_datetime(df['Order_Date'] + ' ' + df['Order_Time'], errors='coerce') # Use errors='coerce'
df['Pickup_Datetime'] = pd.to_datetime(df['Order_Date'] + ' ' + df['Pickup_Time'], errors='coerce') # Use errors='coerce'
df['Order_to_Pickup_Minutes'] = (df['Pickup_Datetime'] - df['Order_Datetime']).dt.total_seconds() / 60

# Extract features
df['Order_Hour'] = df['Order_Datetime'].dt.hour
df['Order_Weekday'] = df['Order_Datetime'].dt.weekday
df['Is_Weekend'] = df['Order_Weekday'].isin([5, 6]).astype(int)

# Plot delivery time distribution
plt.figure(figsize=(8, 5))
sns.histplot(df['Delivery_Time'], bins=30, kde=True)
plt.title("Delivery Time Distribution")
plt.xlabel("Hours")
plt.ylabel("Frequency")
plt.tight_layout()
plt.show()

# Delivery time vs. weather
plt.figure(figsize=(8, 5))
sns.boxplot(x='Weather', y='Delivery_Time', data=df)
plt.title("Delivery Time by Weather Conditions")
plt.tight_layout()
plt.show()

# Delivery time vs. traffic
plt.figure(figsize=(8, 5))
sns.boxplot(x='Traffic', y='Delivery_Time', data=df)
plt.title("Delivery Time by Traffic Conditions")
plt.tight_layout()
plt.show()

# Distance vs. delivery time
plt.figure(figsize=(8, 5))
df['Distance_km'] = df.apply(lambda row: ((row['Drop_Latitude'] - row['Store_Latitude'])**2 + (row['Drop_Longitude'] - row['Store_Longitude'])**2)**0.5, axis=1)
sns.scatterplot(x='Distance_km', y='Delivery_Time', data=df)
plt.title("Distance vs. Delivery Time")
plt.tight_layout()
plt.show()

# Heatmap of correlations
plt.figure(figsize=(10, 8))
corr = df.corr(numeric_only=True)
sns.heatmap(corr, annot=True, cmap="coolwarm")
plt.title("Correlation Heatmap")
plt.tight_layout()
plt.show()

# streamlit_app.py

import streamlit as st
import pandas as pd
import numpy as np
import joblib
from geopy.distance import geodesic
from datetime import datetime
import subprocess
import sys

# Load trained model (assumes Gradient Boosting was saved as model.pkl)
try:
    model = joblib.load("model.pkl")
except FileNotFoundError:
    st.error("Model file 'model.pkl' not found. Please ensure the model training cell was run successfully.")
    st.stop()


st.title("ðŸ•’ Delivery Time Prediction App")
st.markdown("Enter the delivery details below to get an estimated delivery time.")

# User Inputs
agent_age = st.slider("Agent Age", 18, 65, 30)
agent_rating = st.slider("Agent Rating", 1.0, 5.0, 4.5, 0.1)

store_lat = st.number_input("Store Latitude", value=12.9716)
store_lon = st.number_input("Store Longitude", value=77.5946)
drop_lat = st.number_input("Drop Latitude", value=13.0350)
drop_lon = st.number_input("Drop Longitude", value=77.5970)

order_time = st.time_input("Order Time", value=datetime.now().time())
order_date = st.date_input("Order Date", value=datetime.now().date())
pickup_time = st.time_input("Pickup Time", value=datetime.now().time())

weather = st.selectbox("Weather", ["Sunny", "Stormy", "Sandstorms", "Cloudy", "Windy", "Fog"])
traffic = st.selectbox("Traffic", ["Low", "Medium", "High", "Jam"])
vehicle = st.selectbox("Vehicle Type", ["Scooter", "Bike", "Bicycle"])
area = st.selectbox("Area Type", ["Urban", "Metropolitan"])
category = st.selectbox("Product Category", ["Snack Foods", "Beverages", "Beauty & Personal Care", "Household Supplies", "Packaged Foods"])

# Encoders (must match training)
weather_map = {'Sunny': 5, 'Stormy': 4, 'Sandstorms': 3, 'Cloudy': 0, 'Windy': 2, 'Fog': 1}
traffic_map = {'Low': 1, 'Medium': 2, 'High': 0, 'Jam': 3}
vehicle_map = {'Scooter': 2, 'Bike': 0, 'Bicycle': 1}
area_map = {'Urban': 1, 'Metropolitan': 0}
category_map = {
    'Snack Foods': 4,
    'Beverages': 0,
    'Beauty & Personal Care': 1,
    'Household Supplies': 2,
    'Packaged Foods': 3
}

# Feature Calculation
distance = geodesic((store_lat, store_lon), (drop_lat, drop_lon)).km
order_dt = datetime.combine(order_date, order_time)
pickup_dt = datetime.combine(order_date, pickup_time)
time_diff = (pickup_dt - order_dt).total_seconds() / 60
order_hour = order_dt.hour
order_weekday = order_dt.weekday()
is_weekend = 1 if order_weekday >= 5 else 0

# Feature Vector
features = pd.DataFrame([{
    'Agent_Age': agent_age,
    'Agent_Rating': agent_rating,
    'Distance_km': distance,
    'Order_to_Pickup_Minutes': time_diff,
    'Order_Hour': order_hour,
    'Order_Weekday': order_weekday,
    'Is_Weekend': is_weekend,
    'Weather': weather_map[weather],
    'Traffic': traffic_map[traffic],
    'Vehicle': vehicle_map[vehicle],
    'Area': area_map[area],
    'Category': category_map[category]
}])

if st.button("Predict Delivery Time"):
    prediction = model.predict(features)[0]
    st.success(f"Estimated Delivery Time: {prediction:.2f} hours")

# Save the Streamlit app code to a file
with open("streamlit_app.py", "w") as f:
    f.write("""
import streamlit as st
import pandas as pd
import numpy as np
import joblib
from geopy.distance import geodesic
from datetime import datetime

# Load trained model (assumes Gradient Boosting was saved as model.pkl)
try:
    model = joblib.load("model.pkl")
except FileNotFoundError:
    st.error("Model file 'model.pkl' not found. Please ensure the model training cell was run successfully.")
    st.stop()


st.title("ðŸ•’ Delivery Time Prediction App")
st.markdown("Enter the delivery details below to get an estimated delivery time.")

# User Inputs
agent_age = st.slider("Agent Age", 18, 65, 30)
agent_rating = st.slider("Agent Rating", 1.0, 5.0, 4.5, 0.1)

store_lat = st.number_input("Store Latitude", value=12.9716)
store_lon = st.number_input("Store Longitude", value=77.5946)
drop_lat = st.number_input("Drop Latitude", value=13.0350)
drop_lon = st.number_input("Drop Longitude", value=77.5970)

order_time = st.time_input("Order Time", value=datetime.now().time())
order_date = st.date_input("Order Date", value=datetime.now().date())
pickup_time = st.time_input("Pickup Time", value=datetime.now().time())

weather = st.selectbox("Weather", ["Sunny", "Stormy", "Sandstorms", "Cloudy", "Windy", "Fog"])
traffic = st.selectbox("Traffic", ["Low", "Medium", "High", "Jam"])
vehicle = st.selectbox("Vehicle Type", ["Scooter", "Bike", "Bicycle"])
area = st.selectbox("Area Type", ["Urban", "Metropolitan"])
category = st.selectbox("Product Category", ["Snack Foods", "Beverages", "Beauty & Personal Care", "Household Supplies", "Packaged Foods"])

# Encoders (must match training)
weather_map = {'Sunny': 5, 'Stormy': 4, 'Sandstorms': 3, 'Cloudy': 0, 'Windy': 2, 'Fog': 1}
traffic_map = {'Low': 1, 'Medium': 2, 'High': 0, 'Jam': 3}
vehicle_map = {'Scooter': 2, 'Bike': 0, 'Bicycle': 1}
area_map = {'Urban': 1, 'Metropolitan': 0}
category_map = {
    'Snack Foods': 4,
    'Beverages': 0,
    'Beauty & Personal Care': 1,
    'Household Supplies': 2,
    'Packaged Foods': 3
}

# Feature Calculation
distance = geodesic((store_lat, store_lon), (drop_lat, drop_lon)).km
order_dt = datetime.combine(order_date, order_time)
pickup_dt = datetime.combine(order_date, pickup_time)
time_diff = (pickup_dt - order_dt).total_seconds() / 60
order_hour = order_dt.hour
order_weekday = order_dt.weekday()
is_weekend = 1 if order_weekday >= 5 else 0

# Feature Vector
features = pd.DataFrame([{
    'Agent_Age': agent_age,
    'Agent_Rating': agent_rating,
    'Distance_km': distance,
    'Order_to_Pickup_Minutes': time_diff,
    'Order_Hour': order_hour,
    'Order_Weekday': order_weekday,
    'Is_Weekend': is_weekend,
    'Weather': weather_map[weather],
    'Traffic': traffic_map[traffic],
    'Vehicle': vehicle_map[vehicle],
    'Area': area_map[area],
    'Category': category_map[category]
}])

if st.button("Predict Delivery Time"):
    prediction = model.predict(features)[0]
    st.success(f"Estimated Delivery Time: {prediction:.2f} hours")
""")

# Run the Streamlit app
try:
    # Use subprocess to run streamlit run in the background
    process = subprocess.Popen([sys.executable, "-m", "streamlit", "run", "streamlit_app.py"])
    print(f"Streamlit app started with PID: {process.pid}")
except Exception as e:
    print(f"Error starting Streamlit app: {e}")

# To access the app, you'll typically need a tunneling service like ngrok or localtunnel
print("To access the Streamlit app, you may need to use a tunneling service like localtunnel.")
print("You can run the following command in a new cell:")
print("!npx localtunnel --port 8501")

!npm install localtunnel

!streamlit run /expense.py &>/content/logs.txt &